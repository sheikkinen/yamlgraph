# Multi-NPC Encounter with Parallel Processing
#
# This graph runs a turn-by-turn encounter with multiple NPCs.
# Each turn, ALL NPCs perceive, decide, and act in parallel using map nodes.
#
# Usage:
#   python examples/npc/run_multi_encounter.py
#
# Input state:
#   npcs: list of NPC dicts with name, appearance, personality, etc.
#   location: str
#   location_description: str
#
version: "1.0"
name: encounter-multi
description: Multi-turn encounter with multiple NPCs using map nodes

checkpointer:
  type: sqlite
  path: ":memory:"

defaults:
  provider: anthropic
  temperature: 0.7

# Python tools for image generation
tools:
  generate_scene_image:
    type: python
    module: examples.npc.nodes.image_node
    function: generate_scene_image_node
    description: Generate an image of the current scene using Replicate API

state:
  # List of NPCs in the encounter
  npcs: list  # Each NPC is a dict with: name, appearance, voice, personality, behavior, goals

  # Location context
  location: str
  location_description: str

  # Turn state
  turn_number: int
  dm_input: str
  encounter_history: list

  # Per-turn outputs (lists from map nodes)
  perceptions: list     # Each NPC's perception
  decisions: list       # Each NPC's decision
  narrations: list      # Each NPC's narration

  # Combined outputs
  turn_summary: str
  scene_prompt: str
  scene_image: str

nodes:
  # Wait for DM input
  await_dm:
    type: interrupt
    message: |
      ðŸŽ² Turn {state.turn_number} - What happens next?
      NPCs present: {state.npcs}
      (Type 'end' to finish the encounter)
    resume_key: dm_input

  # All NPCs perceive in parallel
  perceive_all:
    type: map
    over: "{state.npcs}"
    as: npc
    node:
      type: llm
      prompt: examples/npc/encounter_perceive
      state_key: perception
      temperature: 0.5
      variables:
        npc_name: "{state.npc.name}"
        npc_personality: "{state.npc.personality}"
        npc_goals: "{state.npc.goals}"
        location: "{state.location}"
        recent_events: "{state.dm_input}"
        other_npcs: "{state.npcs}"
    collect: perceptions

  # All NPCs decide in parallel
  decide_all:
    type: map
    over: "{state.npcs}"
    as: npc
    node:
      type: llm
      prompt: examples/npc/encounter_decide
      state_key: decision
      temperature: 0.7
      variables:
        npc_name: "{state.npc.name}"
        npc_voice: "{state.npc.voice}"
        npc_personality: "{state.npc.personality}"
        npc_behavior: "{state.npc.behavior}"
        perception: "{state.perceptions}"
        encounter_type: "social"
    collect: decisions

  # All NPCs narrate in parallel
  narrate_all:
    type: map
    over: "{state.npcs}"
    as: npc
    node:
      type: llm
      prompt: examples/npc/encounter_narrate
      state_key: narration
      temperature: 0.8
      variables:
        npc_name: "{state.npc.name}"
        npc_appearance: "{state.npc.appearance}"
        location: "{state.location}"
        decision: "{state.decisions}"
    collect: narrations

  # Summarize the entire turn (all NPC actions woven together)
  summarize:
    type: llm
    prompt: examples/npc/encounter_summarize
    state_key: turn_summary
    temperature: 0.6
    skip_if_exists: false
    variables:
      turn_number: "{state.turn_number}"
      location: "{state.location}"
      location_description: "{state.location_description}"
      dm_input: "{state.dm_input}"
      npcs: "{state.npcs}"
      actions: "{state.decisions}"

  # Generate image prompt from combined narrations
  describe_scene:
    type: llm
    prompt: examples/npc/scene_describe
    state_key: scene_prompt
    temperature: 0.6
    skip_if_exists: false
    variables:
      location: "{state.location}"
      location_description: "{state.location_description}"
      narration: "{state.turn_summary}"
      npcs: "{state.npcs}"

  # Generate scene image
  generate_scene_image:
    type: python
    tool: generate_scene_image
    state_key: scene_image

  # Increment turn counter and append to history
  next_turn:
    type: passthrough
    output:
      turn_number: "{state.turn_number + 1}"
      encounter_history: "{state.encounter_history + [state.turn_summary]}"

edges:
  - from: START
    to: await_dm

  # Check if user wants to end
  - from: await_dm
    to: END
    condition: "dm_input == 'end'"

  # Otherwise process the turn
  - from: await_dm
    to: perceive_all
    condition: "dm_input != 'end'"

  - from: perceive_all
    to: decide_all

  - from: decide_all
    to: narrate_all

  - from: narrate_all
    to: summarize

  - from: summarize
    to: describe_scene

  - from: describe_scene
    to: generate_scene_image

  - from: generate_scene_image
    to: next_turn

  # Loop back to await next DM input
  - from: next_turn
    to: await_dm
