system: |
  Generate a precise implementation plan with DEVELOPER INSTRUCTIONS (not code blocks).

  Your output should guide a developer to implement the change correctly.
  Reference exact file paths and line numbers from the Code Analysis.

  ## Instruction Types

  ### EXTRACT
  Move ONE function at a time to a new location:
  ```
  EXTRACT function name1 (lines X-Y) from file.py → new_module.py
  ```
  ⚠️ IMPORTANT: Create a SEPARATE EXTRACT instruction for EACH function.
  Do NOT combine multiple functions into one instruction.

  ### MODIFY
  Change existing code in place:
  ```
  MODIFY function_name (lines X-Y) in file.py: add parameter 'timeout: int = 30'
  ```

  ### ADD
  Add new code:
  ```
  ADD import statement at line X in file.py: 'from module import func'
  ADD function new_func after line X in file.py: [brief description of what it does]
  ```

  ### DELETE
  Remove ONE function at a time:
  ```
  DELETE function name1 (lines X-Y) in file.py (moved to new_module.py)
  ```
  ⚠️ IMPORTANT: Create a SEPARATE DELETE instruction for EACH function.

  ### CREATE
  New file:
  ```
  CREATE new_module.py with functions: [list] extracted from old_module.py
  ```

  ## CRITICAL RULES
  - Always include LINE NUMBERS from the Code Analysis
  - ONE function per EXTRACT/DELETE instruction (atomic operations)
  - For refactoring: specify source lines, not rewritten code
  - Order instructions by dependency (imports before usage)
  - Keep instructions atomic (one action per instruction)
  - If a function should NOT be moved, do not include it in EXTRACT/DELETE

user: |
  Create an implementation plan for:

  **Request**: {{ story }}

  **Change Type**: {{ parsed_request.change_type }}
  {% if parsed_request.change_type == 'refactor' %}
  ⚠️ REFACTOR TASK - Use EXTRACT/DELETE instructions with exact line numbers.
  Do NOT write new code - reference existing code by line numbers.
  {% endif %}

  **Parsed Request**: {{ parsed_request }}

  **Code Analysis**:
  {{ code_analysis }}

  Generate step-by-step developer instructions with exact line references.

schema:
  name: ImplementationPlan
  fields:
    summary:
      type: str
      description: "One-line summary of what changes are needed"
    already_exists:
      type: list[str]
      description: "Features that already exist and can be reused"
      optional: true
    instructions:
      type: list[str]
      description: |
        Ordered list of developer instructions. ONE function per EXTRACT/DELETE.
        Examples:
        - "EXTRACT function print_run_tree (lines 147-170) from utils/langsmith.py → utils/tracing.py"
        - "EXTRACT function _print_run_node (lines 173-248) from utils/langsmith.py → utils/tracing.py"
        - "DELETE function print_run_tree (lines 147-170) in utils/langsmith.py (moved to tracing.py)"
        - "DELETE function _print_run_node (lines 173-248) in utils/langsmith.py (moved to tracing.py)"
        - "ADD import at line 15 in utils/langsmith.py: 'from .tracing import print_run_tree'"
        - "MODIFY get_client (lines 18-42) in utils/langsmith.py: add caching decorator"
        - "CREATE utils/tracing.py with extracted functions + imports from langsmith.py"
    test_instructions:
      type: list[str]
      description: "Test file changes needed (which tests to update/add)"
    risks:
      type: list[str]
      description: "Potential issues: circular imports, backward compatibility, etc."
      optional: true
